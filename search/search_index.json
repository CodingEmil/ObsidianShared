{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> Daten\u00fcbertragung und Protokolle  Embedded Systems 2 </p>"},{"location":"DUP/DUP/","title":"DUP","text":"<p>Strukturierte Verkabelung Twisted-Pair-Kabel Kategorien von Twisted-Pair-Kabeln (Cat) Glasfaser \u00dcbertragungsstandards Topologie Struktur des OSI-Modells 1. Schicht Bit\u00fcbertragungsschicht, Physical-Layer 2. Schicht Sicherungsschicht, Data Link Layer 3. Schicht Vermittlungsschicht, Network-Layer Schachtelung - TCP IP-Modell ARP - Address Resolution Protocol Switch DHCP Router</p>"},{"location":"DUP/Topologie/","title":"Topologie","text":"<p>Auf den Etagen werden die Anschlussdosen an einen Etagenswitch gesetzt. Dieser Etagenswitch wird dann mit Geb\u00e4udeswitches verbunden. Diese Verbindung hat somit den ganzen Traffic von einer Etage, daher wird hier eine h\u00f6here Datenrate vorgesehen (aktuell Cat7 10GBASE-T). Die Geb\u00e4ude untereinander werden eigentlich nur noch mit Glasfaser verbunden (100GBit/s, 100GBASE-FR1). </p>"},{"location":"DUP/ARP/ARP%20-%20Address%20Resolution%20Protocol/","title":"ARP   Address Resolution Protocol","text":"<p>ARP erm\u00f6glicht die Zuordnung von IP Adressen zu MAC-Adressen. Die Hauptfunktion in ARP besteht darin, die MAC-Adresse einer bekannten IP-Adresse zu ermitteln. Denn ohne der MAC-Adresse, k\u00f6nnen keine Daten zu einem anderen Ger\u00e4t \u00fcbertragen werden.</p> <ol> <li>Hosts sendet\u00a0ARP-Request\u00a0mit FF-FF-FF-FF-FF-FF. Jedes Ger\u00e4t kriegt dieses Paket.  </li> <li>In dem Ethernet-Frame steht nun die gesuchte IP.  </li> <li>Wird der Hosts, mit dieser IP, gefunden, schickt er eine\u00a0ARP-Replay.</li> </ol>"},{"location":"DUP/ARP/ARP%20-%20Address%20Resolution%20Protocol/#arp-table","title":"ARP-Table","text":"<p>Jeder Host hat eine ARP-Tabelle, in welcher IP-Adressen zu MAC-Adressen zugeordnet sind.  Wie wir sehen, haben wir einige statische Adressen, das sind z.B. Broadcast Adressen (192.168.0.255) oder auch Multicast Adressen (224.0....). Dynamische Eintr\u00e4ge verfallen nach einer Zeit.</p>"},{"location":"DUP/ARP/ARP%20-%20Address%20Resolution%20Protocol/#fehlender-eintrag","title":"Fehlender Eintrag","text":"<p>Fehlt eine IP in der ARP-Tabelle, dann l\u00f6st ARP eine ARP-Request aus, welches ein Paket an (FF:FF:FF:FF:FF:FF Broadcast Adresse in Layer 2) an alle Ger\u00e4te im Netz schickt. Nun \u00fcberpr\u00fcfen alle Hosts in dem Netzwerk, ob sie die Adresse haben und falls ja, antwortet dieser Host und tr\u00e4gt die eigene MAC Adresse in den Ethernet-Frame ein. Die Ziel-Adresse ist entweder wieder die Broadcast Adresse, oder die des Hosts, der die Request geschickt hat.  Beim Empfang wird die MAC-Adresse in die Tabelle eingetragen.</p>"},{"location":"DUP/DHCP/DHCP/","title":"DHCP","text":"<p>Ein DHCP-Server vergibt automatisch IP-Adressen, aus festgelegten Adress-Pools, an Netzwerkteilnehmer. Dabei wird die Host-IP und Standardgateway (optional: Subnetzmaske, DNS-Server, TFTP-Server) \u00fcbergeben.</p> <ol> <li>DHCP-Discover     Der Host, welcher eine IP braucht, schickt ein Anfrage ins Netz, mit der Suche nach einem DHCP-Server.</li> <li>DHCP-Offer     Der DHCP-Server sucht eine Adresse aus dem Pool aus und broadcastet, dass er diese IP vergeben k\u00f6nnte.</li> <li>DHCP-Request     Host broadcastet, dass er die IP nimmt.</li> <li>DHCP-Acknowledge     DHCP-Server broadcastet eine Best\u00e4tigung.</li> </ol>"},{"location":"DUP/DHCP/DHCP/#lease-time","title":"Lease-Time","text":"<p>Die Lease-Time ist die Zeit, wie lange ein Host die gleiche IP-Adressen, von dem DHCP-Server, bekommt. Steht hier 2 Monate, dann w\u00fcrde der Host erst nach 2 Monaten eine neue IP Adresse bekommen. Diese Zeit kann man im DHCP-Server konfigurieren.</p>"},{"location":"DUP/Kabeltypen/Glasfaser/","title":"Glasfaser","text":"<ul> <li>ohne Verst\u00e4rkung: 10km-120km</li> <li>mit Verst\u00e4rkung: 1000km  Bei der \u00dcbertragung mit Glasfaser werden Lichtsignale verwendet, um Daten \u00fcber gro\u00dfe Entfernungen zu senden. Glasfaserkabel bestehen aus einem d\u00fcnnen Glas- oder Kunststoffkern, der von einer Schicht aus reflektierendem Material umgeben ist, das als Cladding bezeichnet wird. Diese Struktur erm\u00f6glicht die interne Reflexion des Lichts, wodurch die Signale \u00fcber die Faser geleitet werden k\u00f6nnen.</li> </ul> <p>Es gibt zwei Hauptarten von Glasfasern: Singlemode und Multimode.</p>"},{"location":"DUP/Kabeltypen/Glasfaser/#singlemode","title":"Singlemode","text":"<p>Singlemode-Fasern haben einen kleinen Kern und erm\u00f6glichen die \u00dcbertragung von Licht in nur einer Wellenl\u00e4nge. Das Licht breitet sich in gerader Linie durch den Kern aus und erreicht das andere Ende des Kabels, ohne dabei durch Reflexionen oder Dispersion gest\u00f6rt zu werden. Singlemode-Fasern werden f\u00fcr lange Strecken eingesetzt, beispielsweise in Telekommunikationsnetzen oder Unterwasserkabeln.</p>"},{"location":"DUP/Kabeltypen/Glasfaser/#multimode","title":"Multimode","text":"<p>Multimode-Fasern haben einen gr\u00f6\u00dferen Kern und erlauben die \u00dcbertragung von Licht in mehreren Modi, also verschiedenen Lichtpfaden. Die Lichtstrahlen nehmen unterschiedliche Wege durch den Kern und erreichen das andere Ende mit geringf\u00fcgigen zeitlichen Verschiebungen. Dies kann zu Dispersion f\u00fchren, bei der sich die Signale \u00fcber l\u00e4ngere Entfernungen ausbreiten und sich gegenseitig st\u00f6ren. Multimode-Fasern werden typischerweise in k\u00fcrzeren Strecken verwendet, wie z.B. in lokalen Netzwerken (LANs) oder Geb\u00e4udeverkabelungen.</p>"},{"location":"DUP/Kabeltypen/Glasfaser/#unterschied","title":"Unterschied","text":"<p>Der Hauptunterschied zwischen Singlemode- und Multimode-Fasern liegt also im Durchmesser des Glasfaserkerns und in der Art und Weise, wie das Licht durch die Faser geleitet wird. Singlemode-Fasern erm\u00f6glichen eine l\u00e4ngere Reichweite und h\u00f6here Bandbreiten, w\u00e4hrend Multimode-Fasern f\u00fcr k\u00fcrzere Distanzen und geringere Bandbreiten geeignet sind.</p>"},{"location":"DUP/Kabeltypen/Kategorien%20von%20Twisted-Pair-Kabeln%20%28Cat%29/","title":"Kategorien von Twisted Pair Kabeln (Cat)","text":"<ul> <li>Cat 7 ist in Deutschland das \u00fcblichste</li> <li>1 Gigabit ist der Standard unseren Hosts</li> </ul>"},{"location":"DUP/Kabeltypen/Twisted-Pair-Kabel/","title":"Twisted Pair Kabel","text":"<ul> <li>verdrillte 2er Paare</li> <li>2er Paare miteinander verdrillt { width=\"250\" } Dadurch das beim Twisted-Pair-Kabel die einzelnen Adern zu 2. und die Aderpaare miteinander verdrillt sind, werden St\u00f6reinfl\u00fcsse (elektromagnetische Abstrahlung) minimiert.  Je h\u00f6her die Datenrate (somit auch Signalfrequenz), desto empfindlicher auf \u00e4u\u00dfere St\u00f6reinfl\u00fcsse. Zu diesem Zweck gibt es Kabel, welche zus\u00e4tzlich geschirmt sind. Aufbau: Gesamtschirm/Adernpaarschirm { width=\"400\" } S = Drahtgeflecht F = Folienschirm</li> </ul>"},{"location":"DUP/Kabeltypen/%C3%9Cbertragungsstandards/","title":"\u00dcbertragungsstandards","text":""},{"location":"DUP/Kabeltypen/%C3%9Cbertragungsstandards/#aufbau","title":"Aufbau","text":"<p>$\\color{red}1000\\color{lightblue}BASE-\\color{green}T$ $\\color{red}Geschwindigkeit$ $\\color{lightblue}Basisband$ $\\color{green}Leitungstyp$</p> <p>T = Twisted Pair FL = Glasfaser (Fiber Link) SX = Multimode-Glasfaser mit kurzwelligem Licht (Short Wavelength Extended) LX = Singlemode- oder Multimode-Glasfaser mit langwelligem Licht (Long Wavelength Extended) SR = spezifische Art von Multimode\u00fcbertragung, f\u00fcr kurze Reichweiten (Short Reach) LR = spezifische Art von Singlemode\u00fcbertragung, f\u00fcr gr\u00f6\u00dfere Reichweiten (Long Reach)</p> Typ Bedeutung 10Base-5 10MBit/s, 500m 10Base-2 10MBit/s, 180m 10Base-T 10MBit/s, Twisted Pair 10Base-FL 10MBit/s, Glasfaser, Single- oder Multimode 100Base-TX 100MBit/s, Twisted Pair 100Base-FX 100MBit/s, Glasfaser, Single- oder Multimode 1000Base-SX 1GBit/s, Glasfaser, Multimode 1000Base-TX 1GBit/s, Twisted Pair 1000Base-LX 1GBit/s, Glasfaser, Single- oder Multimode 1000Base-SX 1GBit/s, Glasfaser, Multimode 10GBase-T 10GBit/s, Twisted Pair 10GBase-SR 10GBit/s, Glasfaser, Multimode 10GBase-LR 10GBit/s, Glasfaser, Singlemode"},{"location":"DUP/OSI-Modell/1.%20Schicht%20Bit%C3%BCbertragungsschicht%2C%20Physical-Layer/","title":"1. Schicht Bit\u00fcbertragungsschicht, Physical Layer","text":"<p>Die erste Schicht im OSI-Modell wird als physikalische Schicht bezeichnet. Sie ist die unterste Schicht des Modells und besch\u00e4ftigt sich mit der physischen \u00dcbertragung von Daten \u00fcber das Netzwerkmedium. Die Hauptaufgabe der physikalischen Schicht besteht darin, die Datenbits von einem Sender zu einem Empf\u00e4nger \u00fcber das \u00dcbertragungsmedium zu transportieren.</p> <p>Hier sind einige wichtige Aspekte der physikalischen Schicht:</p> <ol> <li> <p>\u00dcbertragung von Bits: Die physikalische Schicht k\u00fcmmert sich um die \u00dcbertragung von Rohdatenbits \u00fcber das physische Medium. Sie definiert die elektrischen, optischen oder drahtlosen Eigenschaften des Mediums, einschlie\u00dflich der Spannungspegel, der Signaleigenschaften und der Verbindungstypen.</p> </li> <li> <p>Codierung: Um die digitalen Datenbits \u00fcber das \u00dcbertragungsmedium zu \u00fcbertragen, werden spezifische Codierungsschemata verwendet. Diese Codierung wandelt die digitalen Bits in physische Signale um, die \u00fcber das Medium \u00fcbertragen werden k\u00f6nnen. Beispiele f\u00fcr Codierungsschemata sind NRZ (Non-Return-to-Zero) oder Manchester-Codierung.</p> </li> <li> <p>Signalisierung: Die physikalische Schicht ist auch f\u00fcr die Erzeugung und Interpretation der Signale zust\u00e4ndig. Die Signale k\u00f6nnen elektrischer, optischer oder elektromagnetischer Natur sein, abh\u00e4ngig vom verwendeten \u00dcbertragungsmedium. Sie m\u00fcssen klar definiert und interpretierbar sein, um eine erfolgreiche Daten\u00fcbertragung zu erm\u00f6glichen.</p> </li> <li> <p>\u00dcbertragungsmedien: Die physikalische Schicht unterst\u00fctzt verschiedene \u00dcbertragungsmedien wie Kupferkabel, Glasfaser oder drahtlose Verbindungen. Jedes Medium hat spezifische Eigenschaften, wie \u00dcbertragungsgeschwindigkeit, Reichweite und St\u00f6ranf\u00e4lligkeit, die in dieser Schicht ber\u00fccksichtigt werden m\u00fcssen.</p> </li> <li> <p>Verbindungen: Die physikalische Schicht ist auch f\u00fcr die physische Verbindung zwischen den Netzwerkger\u00e4ten verantwortlich. Dies beinhaltet die Steckverbinder, Kabeltypen und die mechanischen Aspekte der Verbindung.</p> </li> </ol> <p>Das Hauptziel der physikalischen Schicht besteht darin, eine zuverl\u00e4ssige physische Verbindung zwischen den Netzwerkger\u00e4ten herzustellen und die Datenbits \u00fcber das Medium zu transportieren. Sie legt die Grundlage f\u00fcr die dar\u00fcber liegenden Schichten des OSI-Modells, die sich mit h\u00f6heren abstrakten Konzepten wie Adressierung, Routing und Anwendungsprotokollen befassen.</p>"},{"location":"DUP/OSI-Modell/2.%20Schicht%20Sicherungsschicht%2C%20Data%20Link%20Layer/","title":"2. Schicht Sicherungsschicht, Data Link Layer","text":"<p>Note</p> <p>typisches Protokoll: Ethernet</p> <p>In den meisten F\u00e4llen wird auf der Schicht 2, Ethernet als Standard verwendet. Bei Ethernet werden die Nutzdaten in einzelne Frames unterteilte. Jeder Frame hat eine Kopfzeile (Header). </p>"},{"location":"DUP/OSI-Modell/2.%20Schicht%20Sicherungsschicht%2C%20Data%20Link%20Layer/#ethernet-paket","title":"Ethernet Paket","text":""},{"location":"DUP/OSI-Modell/2.%20Schicht%20Sicherungsschicht%2C%20Data%20Link%20Layer/#praambel-und-sdf","title":"Pr\u00e4ambel und SDF","text":"<p>Dient dazu, dass der Empf\u00e4nger auf den Empfang eines Frames vorbereitet ist.</p>"},{"location":"DUP/OSI-Modell/2.%20Schicht%20Sicherungsschicht%2C%20Data%20Link%20Layer/#ziel-mac-adresse","title":"Ziel-MAC-Adresse","text":"<p>MAC-Adresse, an welches Ger\u00e4t dieses Paket gehen soll.</p>"},{"location":"DUP/OSI-Modell/2.%20Schicht%20Sicherungsschicht%2C%20Data%20Link%20Layer/#quell-mac-adresse","title":"Quell-MAC-Adresse","text":"<p>MAC-Adresse, von welche Ger\u00e4t dieses Paket geschickt wurde.</p>"},{"location":"DUP/OSI-Modell/2.%20Schicht%20Sicherungsschicht%2C%20Data%20Link%20Layer/#vlan-tag","title":"VLAN-Tag","text":""},{"location":"DUP/OSI-Modell/2.%20Schicht%20Sicherungsschicht%2C%20Data%20Link%20Layer/#typ-feld","title":"TYP-Feld","text":"<p>Hier wird beschrieben, welche Art die Nutzdaten sind. Hier steht dann ein Protokoll aus Layer 3 (z.B. IP, ICMP, ARP, RIP).</p>"},{"location":"DUP/OSI-Modell/2.%20Schicht%20Sicherungsschicht%2C%20Data%20Link%20Layer/#daten","title":"Daten","text":"<p>Die eigentlichen Daten.</p>"},{"location":"DUP/OSI-Modell/2.%20Schicht%20Sicherungsschicht%2C%20Data%20Link%20Layer/#pad-fullfeld","title":"PAD-F\u00fcllfeld","text":"<p>Der Ethernet-Frame braucht eine bestimmte L\u00e4nge, sind die Daten jedoch zu gering, dann werden sie mit dem PAD-F\u00fcllfeld auf diese L\u00e4nge aufgef\u00fcllt.</p>"},{"location":"DUP/OSI-Modell/2.%20Schicht%20Sicherungsschicht%2C%20Data%20Link%20Layer/#crc-prufungssumme","title":"CRC-Pr\u00fcfungssumme","text":"<p>Hier werden Bitfehler erkannt, also ob die Datei auf dem Transport weg besch\u00e4digt wurde.</p>"},{"location":"DUP/OSI-Modell/3.%20Schicht%20Vermittlungsschicht%2C%20Network-Layer/","title":"3. Schicht Vermittlungsschicht, Network Layer","text":"<p>Note</p> <p>typisches Protokoll: Internet-Protokoll (IP) IPv4 und IPv6</p> <p>Mit IP kann man nun auch Netzwerk\u00fcbergreifend kommunizieren (Ende-zu-Ende), anders wie bei Ethernet (Punkt-zu-Punkt). Auch bei IP werden die Nutzdaten + Header in kleine Abschnitte verpackt. Hier haben wir keine Frames (Ethernet) sonder Pakete (IP).</p>"},{"location":"DUP/OSI-Modell/3.%20Schicht%20Vermittlungsschicht%2C%20Network-Layer/#aufbau-eines-ip-paketes","title":"Aufbau eines IP-Paketes","text":""},{"location":"DUP/OSI-Modell/3.%20Schicht%20Vermittlungsschicht%2C%20Network-Layer/#version","title":"Version","text":"<p>4 Bit. Die IP-Version (Version 4 oder Version 6).</p>"},{"location":"DUP/OSI-Modell/3.%20Schicht%20Vermittlungsschicht%2C%20Network-Layer/#ihl","title":"IHL","text":"<p>4 Bit. Wie lang der Header ist, steht hier. Aber als Vielfachen von 32 Bit. (steht hier 5, ist der Header $5\\cdot32Bit=160Bit$ lang)</p>"},{"location":"DUP/OSI-Modell/3.%20Schicht%20Vermittlungsschicht%2C%20Network-Layer/#header-prufsumme","title":"Header-Pr\u00fcfsumme","text":"<p>Wie bei Ethernet wird eine Pr\u00fcfsumme, die \u00dcbertragungsfehler korrigiert, erstellt.</p>"},{"location":"DUP/OSI-Modell/3.%20Schicht%20Vermittlungsschicht%2C%20Network-Layer/#protokoll","title":"Protokoll","text":"<p>Hier wird das Protokoll angegeben, welches auf Schicht 4 verwendet wird (TCP oder UDP).</p>"},{"location":"DUP/OSI-Modell/3.%20Schicht%20Vermittlungsschicht%2C%20Network-Layer/#ttl","title":"TTL","text":"<p>Gibt die maximale Anzahl an Hops im Netzwerk an. Datenfeld ist ein Oktett, daher ist der Wertebereich 0 bis 255. Erreicht es nach Ablauf der Zeit nicht das Ziel, wird es verworfen.</p>"},{"location":"DUP/OSI-Modell/3.%20Schicht%20Vermittlungsschicht%2C%20Network-Layer/#total-length","title":"Total Length","text":"<p>16 Bit. Gibt die L\u00e4nge des gesamten Paktes (inkl. Header) in Byte an. </p>"},{"location":"DUP/OSI-Modell/3.%20Schicht%20Vermittlungsschicht%2C%20Network-Layer/#identification","title":"Identification","text":"<p>16 Bit. Identification, Flags und Fragment Offset, helfen bei der Zusammensetzung von den fragmentierten IP-Datenpaketen. Durch die Identification, kann der Empf\u00e4nger erkennen, welche Fragmente zueinander geh\u00f6ren.</p>"},{"location":"DUP/OSI-Modell/3.%20Schicht%20Vermittlungsschicht%2C%20Network-Layer/#flags","title":"Flags","text":"3 Bit Bedeutung Bit 0 reserviert, muss 0 sein Bit 1 Wenn 1; Paket darf nicht zerlegt (fragmentiert) werden Bit 2 Wenn 1; Es folgt ein weiteres Fragment, wenn 0; dieses Paket war das letzte"},{"location":"DUP/OSI-Modell/3.%20Schicht%20Vermittlungsschicht%2C%20Network-Layer/#fragment-offset","title":"Fragment Offset","text":"<p>13 Bit. Zeigt in fragmentierten Paketen an, ab welcher Position im Paket, das Fragment anf\u00e4ngt. </p>"},{"location":"DUP/OSI-Modell/Schachtelung%20-%20TCP%20IP-Modell/","title":"Schachtelung   TCP IP Modell","text":"<p>Schachteln ist das Verpacken von Paketen h\u00f6herer Schichten in Pakete niedriger Schichten. Streng genommen ist das unten abgebildete Modell nicht das OSI-Modell, sondern das DoD-Schichtenmodell oder TCP/IP-Modell. ![[Pasted image 20230620122613.png| center | 400]] In diesem Modell wird visualisiert, wie das Internet funktioniert. Wir haben irgendwelche Nutzdaten auf der Applikationsschicht. Diese wollen wir nun an einen Computer, irgendwo im Internet, senden.  Dazu kommen die Nutzdaten in die unterliegende Schicht, Transportschicht, wo sie einen TCP-Header bekommen. Hier wird zum Beispiel TCP oder UDP genutzt. Im Beispiel von TCP wird hier sichergestellt, dass die Datenpakete in der richtigen Reihenfolge ankommen und Fehler korrigiert werden. Nun kommen die Daten in die Internetschicht, hier sind also alle Daten, welcher zuvor hinzugef\u00fcgt wurden. An diese Daten kommt jetzt noch ein IP-Header. Die Internetschicht ist f\u00fcr die Weiterleitung von Daten, \u00fcber verschiedenen Netzwerke, zust\u00e4ndig. Dazu wird oft das IP-Protokoll genutzt. Zuletzt kommen all diese Daten in die Netzzugangsschicht, welche sich darum k\u00fcmmert, dass die Datenpakete in ein Format kommen, welches f\u00fcr die \u00dcbertragung \u00fcber ein physikalisches Medium geeignet ist (z.B. in Bits</p>"},{"location":"DUP/OSI-Modell/Struktur%20des%20OSI-Modells/","title":"Struktur des OSI Modells","text":"<p>Wir haben Millionen von verschiedenen Endger\u00e4ten in unseren Netzen, aber irgendwie muss schlie\u00dflich regeln, wie diese miteinander kommunizieren. Das macht man mit dem OSI-Modell. Dieses gibt eine Struktur an. Das Modell ist aus 7 Schichten aufgebaut, wobei 1-4 als \"Transportschichten\" und 5-7 als \"Anwendungsschichten\" bezeichnet werden.  Die Transportschichten haben die Aufgabe Daten von einem Ger\u00e4t zum anderen zu \u00fcbertragen und die Anwendungsschichten den Inhalt im Betriebssystem und den Applikationen zu verteilen.</p>"},{"location":"DUP/OSI-Modell/Struktur%20des%20OSI-Modells/#1-bitubertragungsschicht-physical-layer","title":"1. (Bit\u00fcbertragungsschicht, Physical-Layer)","text":"<ul> <li>nur Hardware Hardware wie Leitungstypen, Steckerverbinder und Medien (WLAN, Kupfer oder Glas)</li> </ul>"},{"location":"DUP/OSI-Modell/Struktur%20des%20OSI-Modells/#2sicherungsschicht-data-link-layer","title":"2.(Sicherungsschicht, Data Link Layer)","text":"<ul> <li>Punkt-zu-Punkt</li> <li>Fehlererkennung (CRC)</li> <li>Zugriffssteuerung auf physische Medien Hat die Aufgabe eine einen zuverl\u00e4ssigen Datenfluss zwischen dem n\u00e4chsten Netzwerkger\u00e4t herzustellen (Punkt-zu-Punkt).</li> </ul>"},{"location":"DUP/OSI-Modell/Struktur%20des%20OSI-Modells/#3-vermittlungsschicht-network-layer","title":"3. (Vermittlungsschicht, Network Layer)","text":"<ul> <li>Ende-zu-Ende</li> <li>logische Adressierung</li> <li>Routing Stellt sicher, dass das Ziel \u00fcber mehrere Daten erreicht wird (Ende-zu-Ende). Wie Daten ihren Weg, durch/s Netzwerk/e zu finden.</li> </ul>"},{"location":"DUP/Router/Router/","title":"Router","text":"<p>Note</p> <p>Arbeitet auf Layer 3</p> <p>Verschiedene Netzwerke werden \u00fcber Router miteinander verbunden. Ein Router arbeitet auf Layer 3, kommuniziert also mit IP-Adressen.</p>"},{"location":"DUP/Router/Router/#default-gateway","title":"Default-Gateway","text":"<p>Ein Beispiel f\u00fcr ein Default Gateway ist der Router, der mit dem lokalen Netzwerk verbunden ist und die Verbindung zum Internet herstellt. Wenn ein Ger\u00e4t im lokalen Netzwerk eine Anfrage an eine externe IP-Adresse sendet, wird die Anfrage an das Default Gateway (den Router) weitergeleitet. Der Router leitet dann die Anfrage an das externe Netzwerk weiter und erm\u00f6glicht so den Zugriff auf Ressourcen au\u00dferhalb des lokalen Netzwerks, wie z.B. das Surfen im Internet.</p>"},{"location":"DUP/Router/Router/#adressierung-von-paketen","title":"Adressierung von Paketen","text":"<p> Adressierung Bsp. Haben wir Pakete im lokalen Netz, dann ist die Ziel-MAC und Ziel-IP von dem gleichen Ger\u00e4t. Gehen wir aber nun aus unserem Netzwerk hinaus, \u00fcber den Router, dann ist die Ziel-IP, die von dem eigentlichen Ziel (z.B. Website) und die Ziel-MAC, die von unserem Router.</p> <p>Note</p> <p>Gibt das endg\u00fcltige Ziel an, den ein Paket erreichen soll (Ende-zu-Ende)</p> <p>Note</p> <p>Gibt den n\u00e4chsten Host an, den ein Paket erreichen soll (Punkt-zu-Punkt)</p>"},{"location":"DUP/Strukturierte%20Verkabelung/Strukturierte%20Verkabelung/","title":"Strukturierte Verkabelung","text":"<p>Ein Konzept f\u00fcr Verkabelung mit anwendungsneutralen Kommunikationskabeln in und zwischen Geb\u00e4uden. Sie wird in Prim\u00e4r-, Sekund\u00e4r- und Terti\u00e4rbereich aufgeteilt. </p>"},{"location":"DUP/Strukturierte%20Verkabelung/Strukturierte%20Verkabelung/#primarbereich","title":"Prim\u00e4rbereich","text":"<ul> <li>Standortverteile &lt;--&gt; Geb\u00e4udeverteiler</li> <li>weite Strecken</li> <li>hohe Daten</li> <li>Glasfaserkabel: 2000m</li> <li>fr\u00fcher auch Kupfer: Twisted-Pair-Kabel mit VDSL-Modem: 800m (bei 26MB/s) Wir haben einen Campus. Auf diesem Campus sind verschiedene Geb\u00e4ude, welche miteinander verbunden sind. Der Verbindung der Geb\u00e4ude untereinander, ist die Prim\u00e4rverkabelung. Man nutzt Glasfaser, da wir hier eine riesige Menge an Daten haben und relativ weite Distanzen.</li> </ul>"},{"location":"DUP/Strukturierte%20Verkabelung/Strukturierte%20Verkabelung/#sekundarbereich","title":"Sekund\u00e4rbereich","text":"<ul> <li>Geb\u00e4udeverteiler &lt;--&gt; Etagenverteiler</li> <li>Glasfaserkabel: 2000m</li> <li>Kupfer: Twisted-Pair-Kabel: 100m ([[Kategorien von Twisted-Pair-Kabeln (Cat)|10GBASE-T bei Cat7]]) Jetzt sind wir z.B. in Geb\u00e4ude 5 wo wir mehrere Etagen haben, die Verkabelung zwischen den Etagen ist die Sekund\u00e4rverkabelung.</li> </ul>"},{"location":"DUP/Strukturierte%20Verkabelung/Strukturierte%20Verkabelung/#tertiarbereich","title":"Terti\u00e4rbereich","text":"<ul> <li>Stockwerkverteiler &lt;--&gt; Anschlussdose</li> <li>Kupfer: Twisted-Pair-Kabel: 100m Das ist nun die Verkabelung auf der Etage. Also z.B. vom Switch zum Computer.</li> </ul>"},{"location":"DUP/Strukturierte%20Verkabelung/Strukturierte%20Verkabelung/#ubertragungsstandards","title":"\u00dcbertragungsstandards","text":""},{"location":"DUP/Switches/Switch/","title":"Switch","text":"<p>Note</p> <ul> <li>Layer 1 und 2</li> <li>gibt auch Layer 3 Switches (Multilayerswitches) </li> <li>parallele \u00dcbertragung (Gegensatz zum Hub)</li> </ul> <p>An einem Switch werden alle Netzwerkger\u00e4te angeschlossen, auch andere Switches. Der Switch erzeugt eine Sterntopologie. Der Switch schaltet Datenverkehr anhand von Ziel-MAC-Adressen (im Ethernetframe). Bekommt er einen Frame, wo er die Ziel-MAC-Adresse nicht kennt, dann schickt er ihn an alle Ports (Flooding).</p>"},{"location":"DUP/Switches/Switch/#mac-address-table","title":"MAC-Address-Table","text":"<p>Der Switch hat eine Source-Address-Table (SAT), in welcher er sich merkt, welche MAC-Adresse, an welchem Port ist.  Diese Tabelle kann man auch selber konfigurieren (Typ: static), allerdings lernt der Switch dies auch von selber, nach Zeit (Typ: dynamic). Dazu liest er die Source-MAC-Adresse ein und schreibt diese in die Tabelle, zu dem Port, wo er den Frame erhalten hat.</p>"},{"location":"DUP/Switches/Switch/#kaskadierung-verbinden-mehrerer-switches","title":"Kaskadierung - Verbinden mehrerer Switches","text":"<p>Wenn wir mehrere Switches miteinander verbinden, dann ist das Kaskadierung. Das kann man ohne Probleme machen, allerdings sollte man einen schnelleren Port als Verbindung w\u00e4hlen, da schlie\u00dflich der ganze Traffic von einem Switch auf einen Port, des anderen Switches, geht. Oft haben Switches dazu SFP-Ports (Small Form-factor Pluggable) und SFP-Module, wodurch man auch Glasfaser nutzen kann.</p>"},{"location":"DUP/Switches/Switch/#managed-und-unmanaged-switches","title":"Managed und Unmanaged Switches","text":"<p>Oft reicht ein unmanaged Switch, also ein Switch bei dem man nicht \u00fcber ein Konsolenkabel in eine Konsole kommt. Hier kann man dann aber nat\u00fcrlich auch keine VLANs erstellen. Managed Switches haben eine Konfigurationsschnittstelle (Konsolen Port), wor\u00fcber man diese konfigurieren kann.</p>"},{"location":"DUP/VLANs/PT%20Beispiel/","title":"PT Beispiel","text":"<p>Paket Tracer File</p> <p></p>"},{"location":"DUP/VLANs/PT%20Beispiel/#kommunikation-innerhalb-der-vlans","title":"Kommunikation innerhalb der VLANs","text":"<p>Um eine Kommunikation innerhalb der VLANs zu erm\u00f6glichen (also nicht VLAN zu VLAN):</p>"},{"location":"DUP/VLANs/PT%20Beispiel/#1-vlan-datenbank-switch","title":"1. VLAN Datenbank (Switch)","text":"<p>Die jeweiligen VLANs hinzuf\u00fcgen </p>"},{"location":"DUP/VLANs/PT%20Beispiel/#2-vlan-ports-zuweisen-switch","title":"2. VLAN Ports zuweisen (Switch)","text":"<p>Den einzelnen Ports ein VLAN zuweisen:     Hier Access Mode, da wir nur ein VLAN an einem Port haben. Das nat\u00fcrlich f\u00fcr alle Ports machen, an dem VLANs sind. In dem Beispiel w\u00e4ren das 4, pro Switch 2.  </p>"},{"location":"DUP/VLANs/PT%20Beispiel/#3-trunk-mode-zwischen-switches","title":"3. Trunk Mode zwischen Switches","text":"<p>Zuletzt noch erlauben, dass die VLAN von einem zum anderen Switch \u00fcbertragen werden k\u00f6nnen:     Dazu m\u00fcssen beide Interfaces, zwischen den Switches, im Trunk Mode sein und min. VLAN 10 und VLAN 20 erlauben    Jetzt sind die VLANs in der Lage untereinander zu kommunizieren.</p>"},{"location":"DUP/VLANs/PT%20Beispiel/#kommunikation-zwischen-vlans","title":"Kommunikation zwischen VLANs","text":"<p>Wenn wir zwischen zwei VLANs kommunizieren wollen, dann brauchen wir einen Router. In diesem Router m\u00fcssen wir nun Subinterfaces erstellen. Das bedeutet, dass wir unser Interface, an dem der Switch liegt, in mehrere Interfaces aufteilen (diese sind nat\u00fcrlich dann nur virtuell). </p>"},{"location":"DUP/VLANs/PT%20Beispiel/#1subinterfaces-router","title":"1.Subinterfaces (Router)","text":"<p>Mit <code>interface FastEthernet 0/0.1</code> erstellen wir z.B. schon ein Subinterface.  Jetzt weisen wir diesem Subinterface ein VLAN zu:  Somit ist VLAN 10 nun dem Subinterface 0.1 zugewiesen. Dieses Subinterface bracht nat\u00fcrlich noch einen IP, welche das Default-Gateway f\u00fcr die Ger\u00e4t im VLAN 10 ist.  Pro VLAN erstellen wir ein Subinterface, das hei\u00dft wir haben hier zwei Subinterfaces. Diese werden analog zueinander erstellt.  So sollte unsere Config aussehen: </p>"},{"location":"DUP/VLANs/PT%20Beispiel/#2-trunk-mode-von-switch-zu-router","title":"2. Trunk Mode von Switch zu Router","text":"<p>Damit unsere VLANs nun auch deren Gateway (den Router, bzw. Subinterfaces) erreichen k\u00f6nnen, m\u00fcssen wir nat\u00fcrlich den Port des Switches, zum Router, in Trunkmode setzen und beide VLANs erlauben.  </p>"},{"location":"DUP/VLANs/PT%20Beispiel/#3-gateway","title":"3. Gateway","text":"<p>Zuletzt muss jeder Host die Gateway Adresse (IP der Subinterfaces) haben. Jetzt k\u00f6nnen die Ger\u00e4te VLAN \u00fcbergreifend kommunizieren.</p>"},{"location":"DUP/Vorbereitung%20Klausur/VorbereitungKlausur/","title":"VorbereitungKlausur","text":""},{"location":"DUP/Vorbereitung%20Klausur/VorbereitungKlausur/#1-allgemeine-fragen-zu-subnetzmasken","title":"1) Allgemeine Fragen zu Subnetzmasken","text":"<p>PC:  192.168.10.10 255.255.255.0</p> <p>Server: 192.168.14.10 255.255.255.0</p> <p>Ersichtlich, dass beide Ger\u00e4te nicht im gleichen Netz sind. </p> <p>a) Subnetzmaske in Bin\u00e4r: <code>11111111 11111111 11111111 00000000</code></p> <p>b) Netzadresse des PCs: 192.168.10.0</p> <p>c) Broadcastadresse des PC Netzes: 192.168.10.255</p> <p>d) Anzahl der Hosts: 254 Hosts</p> <p>c) Server und Client k\u00f6nnen nicht ohne Router kommunizieren, das sie in unterschiedlichen Netzen sind.</p>"},{"location":"DUP/Vorbereitung%20Klausur/VorbereitungKlausur/#neue-subnetzmaske-des-pcs","title":"Neue Subnetzmaske des PCs","text":"<p>PC: 192.168.10.10 255.255.0.0</p> <p>f) Netzadresse: 192.168.0.0</p> <p>Broadcastadresse: 192.168.255.255</p> <p>g) Anzahl der Hosts: 65534 Hosts</p> <p>h) Server und Client k\u00f6nnen nicht miteinander kommunizieren, da sie sich immer noch in verschiedenen Subnetzen befinden.</p>"},{"location":"DUP/Vorbereitung%20Klausur/VorbereitungKlausur/#neue-subnetzmaske-des-pcs_1","title":"Neue Subnetzmaske des PCs","text":"<p>PC: 192.168.10.10 255.255.128.0</p> <p>i) Subnetzmaske in Bin\u00e4r: <code>11111111 11111111 10000000 00000000</code></p> <p>j) Netzadresse des Netzes: 192.168.0.0</p> <p>k) Broadcastadresse des Netzes: 192.168.127.255</p> <p>l) Die Ger\u00e4te k\u00f6nnen auch nicht kommunizieren, da sie wieder in unterschiedlichen Subnetzen sind.</p>"},{"location":"DUP/Vorbereitung%20Klausur/VorbereitungKlausur/#2-unterteilung-eines-ip-bereiches-in-verschiedene-subnetze","title":"2) Unterteilung eines IP-Bereiches in verschiedene Subnetze","text":"<p>d) Unser gegebener IP-Adressbereich f\u00e4ngt bei 192.170.0.0 an.</p> <p>192.170.0.0/19</p> <p>&lt;--&gt; Netz A</p> <p>192.170.32.0/19</p> <p>&lt;--&gt; Netz B</p> <p>192.170.64.0/19</p> <p>&lt;--&gt; Netz C</p> <p>192.170.96.0/19</p> <p>&lt;--&gt; Netz D</p> <p>192.170.128.0</p> <p></p>"},{"location":"DUP/Vorbereitung%20Klausur/VorbereitungKlausur/#3-erganzende-aufgaben-zum-subnetting","title":"3) Erg\u00e4nzende Aufgaben zum Subnetting","text":"<p>a) Netzadressen im 255.255.255.224 Netz: 0, 32, 64, $\\color{red}96$, 128, 160, ...</p> <p>Beide PCs sind im 4ten Subnetz (192.168.222.96/27 ($\\color{red}192.168.222.96-192.168.222.127$))</p> <p>b) Netzadressen im 255.255.255.240: 0, $\\color{violet}16$, $\\color{green}32$, 48, ...</p> <p>PC1 ist im 2ten Subnetz und PC2 im 3ten, somit sind sie in unterschiedlichen Subnetzen.</p>"},{"location":"DUP/Vorbereitung%20Klausur/VorbereitungKlausur/#4-vlans","title":"4) VLANs","text":"<p>a)  - IP-Adressen + Subnetzmaske an Subinterfaces vergeben -  - Encapsulation: Zuordnung von Subinterface zu VLAN-ID -  - Falls DHCP-Relay genutzt werden soll: Helper-Adresse konfigurieren -  - Interface einschalten</p> <p>b)   Die beiden Gigabitverbindungen sind zwar im trunk mode, allerdings sind nur VLANs von 20-1001 erlaubt, wodurch VLAN 10 nicht weitergegeben wird. So kann VLAN 10 auch nicht \u00fcber die Switches kommunizieren.</p>"},{"location":"DUP/Vorbereitung%20Klausur/VorbereitungKlausur/#5-statisches-routing-zwischen-zwei-subnetzen","title":"5) Statisches Routing zwischen zwei Subnetzen","text":""},{"location":"DUP/Vorbereitung%20Klausur/VorbereitungKlausur/#11","title":"11)","text":""},{"location":"DUP/Vorbereitung%20Klausur/VorbereitungKlausur/#13","title":"13)","text":""},{"location":"DUP/Vorbereitung%20Klausur/VorbereitungKlausur/#15","title":"15)","text":""},{"location":"DUP/Vorbereitung%20Klausur/VorbereitungKlausur/#16","title":"16)","text":"<ul> <li>Ein m\u00f6glicher Fehler ist, dass in diesem Host, keine Gateway-IP vergeben wird und dieser somit nicht der Router findet. <ul> <li>Dazu k\u00f6nnte man sich einfach der Netzwerkkonfigurationen auf dem Host anschauen und gucken, ob die richtige bzw. \u00fcberhaupt eine Gateway IP vergeben wurde.  </li> </ul> </li> <li>Firewall: Blockierte Ports/IPs<ul> <li>Dazu muss man sich die Firewall-Settings anschauen</li> </ul> </li> </ul>"},{"location":"DUP/Vorbereitung%20Klausur/VorbereitungKlausur/#17","title":"17)","text":""},{"location":"EB2/EB2/","title":"EB2","text":"<p>Rgb lcd.cpp Rgb lcd.h Vorbereitung Praktikum 1 Code Ideen.md </p>"},{"location":"EB2/Praktikum/rgb_lcd.cpp/","title":"Rgb lcd.cpp","text":"<pre><code>/*\n  rgb_lcd.cpp\n  2013 Copyright (c) Seeed Technology Inc.  All right reserved.\n\n  Author:Loovee\n  2013-9-18\n\n  add rgb backlight fucnction @ 2013-10-15\n\n  The MIT License (MIT)\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.1  USA\n*/\n\n#include &lt;Arduino.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;inttypes.h&gt;\n#include &lt;Wire.h&gt;\n\n#include \"rgb_lcd.h\"\n\nrgb_lcd::rgb_lcd()\n{\n}\n\nvoid rgb_lcd::i2c_send_byte(unsigned char dta)\n{\n    _Wire-&gt;beginTransmission(LCD_ADDRESS);        // transmit to device #4\n    _Wire-&gt;write(dta);                            // sends five bytes\n    _Wire-&gt;endTransmission();                     // stop transmitting\n}\n\nvoid rgb_lcd::i2c_send_byteS(unsigned char *dta, unsigned char len)\n{\n    _Wire-&gt;beginTransmission(LCD_ADDRESS);        // transmit to device #4\n    for(int i=0; i&lt;len; i++)\n    {\n        _Wire-&gt;write(dta[i]);\n    }\n    _Wire-&gt;endTransmission();                     // stop transmitting\n}\n\nvoid rgb_lcd::begin(uint8_t cols, uint8_t lines, TwoWire *WireIF, uint8_t dotsize) \n{\n    _Wire = WireIF;\n\n    _Wire-&gt;begin();\n\n    if (lines &gt; 1) {\n        _displayfunction |= LCD_2LINE;\n    }\n    _numlines = lines;\n    _currline = 0;\n\n    // for some 1 line displays you can select a 10 pixel high font\n    if ((dotsize != 0) &amp;&amp; (lines == 1)) {\n        _displayfunction |= LCD_5x10DOTS;\n    }\n\n    // SEE PAGE 45/46 FOR INITIALIZATION SPECIFICATION!\n    // according to datasheet, we need at least 40ms after power rises above 2.7V\n    // before sending commands. Arduino can turn on way befer 4.5V so we'll wait 50\n    delayMicroseconds(50000);\n\n\n    // this is according to the hitachi HD44780 datasheet\n    // page 45 figure 23\n\n    // Send function set command sequence\n    command(LCD_FUNCTIONSET | _displayfunction);\n    delayMicroseconds(4500);  // wait more than 4.1ms\n\n    // second try\n    command(LCD_FUNCTIONSET | _displayfunction);\n    delayMicroseconds(150);\n\n    // third go\n    command(LCD_FUNCTIONSET | _displayfunction);\n\n\n    // finally, set # lines, font size, etc.\n    command(LCD_FUNCTIONSET | _displayfunction);\n\n    // turn the display on with no cursor or blinking default\n    _displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;\n    display();\n\n    // clear it off\n    clear();\n\n    // Initialize to default text direction (for romance languages)\n    _displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;\n    // set the entry mode\n    command(LCD_ENTRYMODESET | _displaymode);\n\n\n    // backlight init\n    setReg(REG_MODE1, 0);\n    // set LEDs controllable by both PWM and GRPPWM registers\n    setReg(REG_OUTPUT, 0xFF);\n    // set MODE2 values\n    // 0010 0000 -&gt; 0x20  (DMBLNK to 1, ie blinky mode)\n    setReg(REG_MODE2, 0x20);\n\n    setColorWhite();\n\n}\n\n/********** high level commands, for the user! */\nvoid rgb_lcd::clear()\n{\n    command(LCD_CLEARDISPLAY);        // clear display, set cursor position to zero\n    delayMicroseconds(2000);          // this command takes a long time!\n}\n\nvoid rgb_lcd::home()\n{\n    command(LCD_RETURNHOME);        // set cursor position to zero\n    delayMicroseconds(2000);        // this command takes a long time!\n}\n\nvoid rgb_lcd::setCursor(uint8_t col, uint8_t row)\n{\n\n    col = (row == 0 ? col|0x80 : col|0xc0);\n    unsigned char dta[2] = {0x80, col};\n\n    i2c_send_byteS(dta, 2);\n\n}\n\n// Turn the display on/off (quickly)\nvoid rgb_lcd::noDisplay()\n{\n    _displaycontrol &amp;= ~LCD_DISPLAYON;\n    command(LCD_DISPLAYCONTROL | _displaycontrol);\n}\n\nvoid rgb_lcd::display() {\n    _displaycontrol |= LCD_DISPLAYON;\n    command(LCD_DISPLAYCONTROL | _displaycontrol);\n}\n\n// Turns the underline cursor on/off\nvoid rgb_lcd::noCursor()\n{\n    _displaycontrol &amp;= ~LCD_CURSORON;\n    command(LCD_DISPLAYCONTROL | _displaycontrol);\n}\n\nvoid rgb_lcd::cursor() {\n    _displaycontrol |= LCD_CURSORON;\n    command(LCD_DISPLAYCONTROL | _displaycontrol);\n}\n\n// Turn on and off the blinking cursor\nvoid rgb_lcd::noBlink()\n{\n    _displaycontrol &amp;= ~LCD_BLINKON;\n    command(LCD_DISPLAYCONTROL | _displaycontrol);\n}\nvoid rgb_lcd::blink()\n{\n    _displaycontrol |= LCD_BLINKON;\n    command(LCD_DISPLAYCONTROL | _displaycontrol);\n}\n\n// These commands scroll the display without changing the RAM\nvoid rgb_lcd::scrollDisplayLeft(void)\n{\n    command(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVELEFT);\n}\nvoid rgb_lcd::scrollDisplayRight(void)\n{\n    command(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVERIGHT);\n}\n\n// This is for text that flows Left to Right\nvoid rgb_lcd::leftToRight(void)\n{\n    _displaymode |= LCD_ENTRYLEFT;\n    command(LCD_ENTRYMODESET | _displaymode);\n}\n\n// This is for text that flows Right to Left\nvoid rgb_lcd::rightToLeft(void)\n{\n    _displaymode &amp;= ~LCD_ENTRYLEFT;\n    command(LCD_ENTRYMODESET | _displaymode);\n}\n\n// This will 'right justify' text from the cursor\nvoid rgb_lcd::autoscroll(void)\n{\n    _displaymode |= LCD_ENTRYSHIFTINCREMENT;\n    command(LCD_ENTRYMODESET | _displaymode);\n}\n\n// This will 'left justify' text from the cursor\nvoid rgb_lcd::noAutoscroll(void)\n{\n    _displaymode &amp;= ~LCD_ENTRYSHIFTINCREMENT;\n    command(LCD_ENTRYMODESET | _displaymode);\n}\n\n// Allows us to fill the first 8 CGRAM locations\n// with custom characters\nvoid rgb_lcd::createChar(uint8_t location, uint8_t charmap[])\n{\n\n    location &amp;= 0x7; // we only have 8 locations 0-7\n    command(LCD_SETCGRAMADDR | (location &lt;&lt; 3));\n\n\n    unsigned char dta[9];\n    dta[0] = 0x40;\n    for(int i=0; i&lt;8; i++)\n    {\n        dta[i+1] = charmap[i];\n    }\n    i2c_send_byteS(dta, 9);\n}\n\n// Control the backlight LED blinking\nvoid rgb_lcd::blinkLED(void)\n{\n    // blink period in seconds = (&lt;reg 7&gt; + 1) / 24\n    // on/off ratio = &lt;reg 6&gt; / 256\n    setReg(0x07, 0x17);  // blink every second\n    setReg(0x06, 0x7f);  // half on, half off\n}\n\nvoid rgb_lcd::noBlinkLED(void)\n{\n    setReg(0x07, 0x00);\n    setReg(0x06, 0xff);\n}\n\n/*********** mid level commands, for sending data/cmds */\n\n// send command\ninline void rgb_lcd::command(uint8_t value)\n{\n    unsigned char dta[2] = {0x80, value};\n    i2c_send_byteS(dta, 2);\n}\n\n// send data\ninline size_t rgb_lcd::write(uint8_t value)\n{\n\n    unsigned char dta[2] = {0x40, value};\n    i2c_send_byteS(dta, 2);\n    return 1; // assume sucess\n}\n\nvoid rgb_lcd::setReg(unsigned char addr, unsigned char dta)\n{\n    _Wire-&gt;beginTransmission(RGB_ADDRESS); // transmit to device #4\n    _Wire-&gt;write(addr);\n    _Wire-&gt;write(dta);\n    _Wire-&gt;endTransmission();    // stop transmitting\n}\n\nvoid rgb_lcd::setRGB(unsigned char r, unsigned char g, unsigned char b)\n{\n    setReg(REG_RED, r);\n    setReg(REG_GREEN, g);\n    setReg(REG_BLUE, b);\n}\n\nconst unsigned char color_define[4][3] = \n{\n    {255, 255, 255},            // white\n    {255, 0, 0},                // red\n    {0, 255, 0},                // green\n    {0, 0, 255},                // blue\n};\n\nvoid rgb_lcd::setColor(unsigned char color)\n{\n    if(color &gt; 3)return ;\n    setRGB(color_define[color][0], color_define[color][1], color_define[color][2]);\n}\n</code></pre>"},{"location":"EB2/Praktikum/rgb_lcd.cpp/#chatgbp-erklarung","title":"ChatGBP Erkl\u00e4rung","text":"<p>Dieser Code ist offenbar eine Implementierung einer Treiberbibliothek f\u00fcr ein RGB-LCD-Display. Hier ist eine Erkl\u00e4rung f\u00fcr jede Zeile des Codes:</p> <ol> <li> <p>Die Kommentarzeilen am Anfang des Codes enthalten Informationen zum Copyright, Autor und zur Lizenz des Codes (MIT-Lizenz), die die Bedingungen f\u00fcr die Verwendung und Verteilung des Codes festlegt.</p> </li> <li> <p>In den Zeilen 7 bis 12 werden verschiedene Header-Dateien und Bibliotheken eingef\u00fcgt, die f\u00fcr den Code ben\u00f6tigt werden. Dazu geh\u00f6ren Arduino, Standard-C-Header, Wire (f\u00fcr die I2C-Kommunikation) und die benutzerdefinierte Header-Datei \"rgb_lcd.h\".</p> </li> <li> <p>In den Zeilen 14 bis 17 wird der Konstruktor f\u00fcr die Klasse \"rgb_lcd\" definiert. Dies ist der Konstruktor, der aufgerufen wird, wenn ein Objekt dieser Klasse erstellt wird. In diesem Fall ist der Konstruktor leer und f\u00fchrt keine speziellen Aktionen aus.</p> </li> <li> <p>Die n\u00e4chsten Zeilen ab Zeile 19 definieren verschiedene Funktionen und Methoden, die von der Klasse \"rgb_lcd\" verwendet werden. Hier sind einige wichtige Funktionen und ihre Erkl\u00e4rungen:</p> </li> <li> <p><code>i2c_send_byte(unsigned char dta)</code>: Diese Funktion sendet ein einzelnes Byte (<code>dta</code>) \u00fcber die I2C-Kommunikation an das LCD-Display.</p> </li> <li> <p><code>i2c_send_byteS(unsigned char *dta, unsigned char len)</code>: Diese Funktion sendet ein Array von Bytes (<code>dta</code>) mit der L\u00e4nge (<code>len</code>) \u00fcber die I2C-Kommunikation an das LCD-Display.</p> </li> <li> <p><code>begin(uint8_t cols, uint8_t lines, TwoWire *WireIF, uint8_t dotsize)</code>: Diese Methode wird aufgerufen, um die Initialisierung des LCD-Displays durchzuf\u00fchren. Sie akzeptiert Parameter wie die Anzahl der Spalten und Zeilen des Displays, den verwendeten I2C-Bus und die Gr\u00f6\u00dfe der Punkte.</p> </li> <li> <p>Die n\u00e4chsten Abschnitte des Codes, insbesondere ab Zeile 52, enthalten die Initialisierung des LCD-Displays gem\u00e4\u00df den Spezifikationen des Hitachi HD44780 Controllers. Dabei werden verschiedene Befehle an das Display gesendet, um die Funktionen, Darstellungsmodi und Hintergrundbeleuchtung zu konfigurieren.</p> </li> <li> <p>Ab Zeile 128 finden sich Methoden, die die Steuerung des Displays erm\u00f6glichen. Dies umfasst das L\u00f6schen des Displays, das Setzen des Cursors, das Ein- und Ausschalten des Displays und die Steuerung des Cursors und des Blinkens.</p> </li> <li> <p>Die Methode <code>createChar</code> (ab Zeile 234) erm\u00f6glicht es, benutzerdefinierte Zeichen auf dem Display zu erstellen.</p> </li> <li> <p>Die Methoden <code>setRGB</code> (ab Zeile 261) und <code>setColor</code> (ab Zeile 280) dienen zur Steuerung der Hintergrundbeleuchtung des Displays, indem sie die Intensit\u00e4t der roten (R), gr\u00fcnen (G) und blauen (B) LEDs einstellen.</p> </li> <li> <p>Schlie\u00dflich gibt es noch einige Hilfsfunktionen und -methoden, die in den vorherigen Funktionen verwendet werden, wie <code>command</code>, <code>write</code>, <code>setReg</code>, <code>blinkLED</code> und <code>noBlinkLED</code>.</p> </li> </ol> <p>Insgesamt handelt es sich bei diesem Code um eine umfangreiche Implementierung einer Treiberbibliothek f\u00fcr ein RGB-LCD-Display, die es erm\u00f6glicht, das Display zu steuern, Text und benutzerdefinierte Zeichen anzuzeigen und die Hintergrundbeleuchtung in verschiedenen Farben zu steuern.</p>"},{"location":"EB2/Praktikum/rgb_lcd.h/","title":"Rgb lcd.h","text":"<pre><code>/*\n  rgb_lcd.h\n  2013 Copyright (c) Seeed Technology Inc.  All right reserved.\n\n  Author:Loovee\n  2013-9-18\n\n  add rgb backlight fucnction @ 2013-10-15\n\n  The MIT License (MIT)\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.1  USA\n*/\n\n\n#ifndef __RGB_LCD_H__\n#define __RGB_LCD_H__\n\n#include &lt;inttypes.h&gt;\n#include \"Print.h\"\n\n// Device I2C Arress\n#define LCD_ADDRESS     (0x7c&gt;&gt;1)\n#define RGB_ADDRESS     (0xc4&gt;&gt;1)\n\n\n// color define \n#define WHITE           0\n#define RED             1\n#define GREEN           2\n#define BLUE            3\n\n#define REG_RED         0x04        // pwm2\n#define REG_GREEN       0x03        // pwm1\n#define REG_BLUE        0x02        // pwm0\n\n#define REG_MODE1       0x00\n#define REG_MODE2       0x01\n#define REG_OUTPUT      0x08\n\n// commands\n#define LCD_CLEARDISPLAY 0x01\n#define LCD_RETURNHOME 0x02\n#define LCD_ENTRYMODESET 0x04\n#define LCD_DISPLAYCONTROL 0x08\n#define LCD_CURSORSHIFT 0x10\n#define LCD_FUNCTIONSET 0x20\n#define LCD_SETCGRAMADDR 0x40\n#define LCD_SETDDRAMADDR 0x80\n\n// flags for display entry mode\n#define LCD_ENTRYRIGHT 0x00\n#define LCD_ENTRYLEFT 0x02\n#define LCD_ENTRYSHIFTINCREMENT 0x01\n#define LCD_ENTRYSHIFTDECREMENT 0x00\n\n// flags for display on/off control\n#define LCD_DISPLAYON 0x04\n#define LCD_DISPLAYOFF 0x00\n#define LCD_CURSORON 0x02\n#define LCD_CURSOROFF 0x00\n#define LCD_BLINKON 0x01\n#define LCD_BLINKOFF 0x00\n\n// flags for display/cursor shift\n#define LCD_DISPLAYMOVE 0x08\n#define LCD_CURSORMOVE 0x00\n#define LCD_MOVERIGHT 0x04\n#define LCD_MOVELEFT 0x00\n\n// flags for function set\n#define LCD_8BITMODE 0x10\n#define LCD_4BITMODE 0x00\n#define LCD_2LINE 0x08\n#define LCD_1LINE 0x00\n#define LCD_5x10DOTS 0x04\n#define LCD_5x8DOTS 0x00\n\nclass rgb_lcd : public Print \n{\n\npublic:\n  rgb_lcd();\n\n  void begin(uint8_t cols, uint8_t rows, TwoWire *WireIF, uint8_t charsize = LCD_5x8DOTS);\n\n  void clear();\n  void home();\n\n  void noDisplay();\n  void display();\n  void noBlink();\n  void blink();\n  void noCursor();\n  void cursor();\n  void scrollDisplayLeft();\n  void scrollDisplayRight();\n  void leftToRight();\n  void rightToLeft();\n  void autoscroll();\n  void noAutoscroll();\n\n  void createChar(uint8_t, uint8_t[]);\n  void setCursor(uint8_t, uint8_t); \n\n  virtual size_t write(uint8_t);\n  void command(uint8_t);\n\n  // color control\n  void setRGB(unsigned char r, unsigned char g, unsigned char b);               // set rgb\n  void setPWM(unsigned char color, unsigned char pwm){setReg(color, pwm);}      // set pwm\n\n  void setColor(unsigned char color);\n  void setColorAll(){setRGB(0, 0, 0);}\n  void setColorWhite(){setRGB(255, 255, 255);}\n\n  // blink the LED backlight\n  void blinkLED(void);\n  void noBlinkLED(void);\n\n  using Print::write;\n\nprivate:\n  void send(uint8_t, uint8_t);\n  void setReg(unsigned char addr, unsigned char dta);\n\n  uint8_t _displayfunction;\n  uint8_t _displaycontrol;\n  uint8_t _displaymode;\n\n  uint8_t _initialized;\n\n  uint8_t _numlines,_currline;\n\n  TwoWire *_Wire;\n  void i2c_send_byte(unsigned char dta);\n  void i2c_send_byteS(unsigned char *dta, unsigned char len);\n};\n\n#endif\n</code></pre>"},{"location":"EB2/Praktikum/rgb_lcd.h/#chatgpb-erklarung","title":"ChatGPB Erkl\u00e4rung","text":"<p>Der gezeigte Code ist eine Header-Datei (<code>.h</code>), die die Deklarationen f\u00fcr eine C++-Klasse mit dem Namen <code>rgb_lcd</code> enth\u00e4lt. Diese Klasse dient als Schnittstelle zur Steuerung eines RGB-LCD-Displays \u00fcber die I2C-Kommunikation. Hier ist eine Erkl\u00e4rung f\u00fcr einige wichtige Teile des Codes:</p> <ol> <li> <p>Die Header-Datei beginnt mit Kommentarzeilen, die Informationen zum Copyright, zum Autor, zum Datum der letzten \u00c4nderung und zur MIT-Lizenz enthalten.</p> </li> <li> <p>Es werden einige Makros und Konstanten definiert, die sp\u00e4ter im Code verwendet werden, um Adressen, Farben und Steuerbefehle f\u00fcr das Display festzulegen.</p> </li> <li> <p>Die Klasse <code>rgb_lcd</code> wird deklariert und von der Arduino <code>Print</code>-Klasse abgeleitet, was bedeutet, dass sie Funktionen f\u00fcr das Schreiben von Daten auf das Display implementiert.</p> </li> <li> <p>In der \u00f6ffentlichen (public) Bereich der Klasse sind die \u00f6ffentlichen Methoden und Funktionen deklariert, die von anderen Teilen des Codes verwendet werden k\u00f6nnen, um das Display zu steuern. Dazu geh\u00f6ren Methoden zum L\u00f6schen des Displays (<code>clear()</code>), zum Setzen des Cursors (<code>setCursor()</code>), zum Ein- und Ausschalten des Displays (<code>display()</code>, <code>noDisplay()</code>), zum Blinken des Cursors (<code>blink()</code>, <code>noBlink()</code>) und viele andere.</p> </li> <li> <p>Es gibt auch Methoden, um die Hintergrundbeleuchtung des Displays zu steuern, wie <code>setRGB()</code>, <code>setPWM()</code>, <code>setColor()</code>, <code>blinkLED()</code> und <code>noBlinkLED()</code>.</p> </li> <li> <p>Die Klasse <code>rgb_lcd</code> erbt von der <code>Print</code>-Klasse, was bedeutet, dass sie auch die <code>write()</code>-Methode implementiert, die verwendet werden kann, um Text und Daten auf das Display zu schreiben.</p> </li> <li> <p>In der privaten (private) Bereich der Klasse sind die internen Methoden und Funktionen deklariert, die von den \u00f6ffentlichen Methoden verwendet werden, um die Kommunikation mit dem Display \u00fcber I2C durchzuf\u00fchren. Dies umfasst Funktionen wie <code>i2c_send_byte()</code>, <code>i2c_send_byteS()</code>, <code>send()</code>, <code>setReg()</code> und <code>command()</code>.</p> </li> <li> <p>Verschiedene Flags und Konstanten f\u00fcr die Konfiguration des Displays und seine Steuerung werden definiert, wie z.B. <code>LCD_ENTRYRIGHT</code>, <code>LCD_DISPLAYON</code>, <code>LCD_MOVELEFT</code>, <code>LCD_2LINE</code> usw.</p> </li> </ol> <p>Insgesamt stellt diese Header-Datei die Deklarationen und Schnittstellen f\u00fcr die Steuerung eines RGB-LCD-Displays bereit und dient als Grundlage f\u00fcr die Implementierung des eigentlichen Treibercodes, der in der vorherigen Antwort gezeigt wurde.</p>"},{"location":"EB2/Praktikum/1.%20Praktikum/Code%20Ideen/","title":"Code Ideen","text":""},{"location":"EB2/Praktikum/1.%20Praktikum/Code%20Ideen/#servo-poti","title":"Servo + Poti","text":"<pre><code>#include &lt;Servo.h&gt;\n\nServo myservo;  // create servo object to control a servo\n\nint potpin = A0;  // analog pin used to connect the potentiometer\nint val;    // variable to read the value from the analog pin\n\nvoid setup() {\n  myservo.attach(9);  // dem Arduino sagen, wo der Servo angeschlossen ist\n}\n\nvoid loop() {\n  val = analogRead(potpin);            // reads the value of the potentiometer (value between 0 and 1023)\n  val = map(val, 0, 1023, 0, 180);     // Poti gibt Wert von 0 &lt;-&gt; 1023, skalieren auf &lt;-&gt; 180 f\u00fcr Servosteuerung\n  myservo.write(val);                  \n  delay(15);                           // waits for the servo to get there\n}\n</code></pre>"},{"location":"EB2/Praktikum/1.%20Praktikum/Code%20Ideen/#eingebaute-led","title":"eingebaute LED","text":"<pre><code>// the setup function runs once when you press reset or power the board\nvoid setup() {\n  // initialize digital pin LED_BUILTIN as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n  digitalWrite(LED_BUILTIN, HIGH);  // turn the LED on (HIGH is the voltage level)\n  delay(1000);                      // wait for a second\n  digitalWrite(LED_BUILTIN, LOW);   // turn the LED off by making the voltage LOW\n  delay(1000);                      // wait for a second\n}\n</code></pre>"},{"location":"EB2/Praktikum/1.%20Praktikum/Code%20Ideen/#serielle-schnittstelle","title":"Serielle Schnittstelle","text":"<pre><code>void setup(){\n  Serial.begin(9600); //9600 (Baudrate) Datenbits pro Sekunde\n}\n\nvoid loop() {\n  Serial.println(\"Hello\");\n  delay(1);\n}\n</code></pre>"},{"location":"EB2/Praktikum/1.%20Praktikum/Code%20Ideen/#taster","title":"Taster","text":"<pre><code>const int buttonPin = 2;\nint buttonState = 0;\n\nvoid setup(){\n  pinMode(buttonPin, INPUT);\n  Serial.begin(9600);\n\n}\n\nvoid loop(){\n  buttonState = digitalRead(buttonPin);\n\n  if (buttonState == HIGH){\n    Serial.println(\"Taster wurde gedr\u00fcckt\");\n  }\n\n}\n</code></pre>"},{"location":"EB2/Praktikum/1.%20Praktikum/Code%20Ideen/#analogwerte-einlesen","title":"Analogwerte einlesen","text":"<pre><code>int sensorPin = A0; //Pin wo der Sensor angeschlossen ist\nint sensorValue = 0;\n\nvoid setup(){\n  Serial.begin(9600);\n}\n\nvoid loop(){\n  sensorValue = analogRead(sensorPin);\n  Serial.println(sensorValue);\n}\n</code></pre>"},{"location":"EB2/Praktikum/1.%20Praktikum/Code%20Ideen/#lcd-display","title":"LCD-Display","text":"<pre><code>#include &lt;Wire.h&gt;  // Einbinden der Wire-Bibliothek f\u00fcr die I2C-Kommunikation\n#include &lt;rgb_lcd.h&gt;  // Einbinden der rgb_lcd-Bibliothek\n\n// Initialisieren des LCD-Objekts\nrgb_lcd lcd;\n\nvoid setup() {\n  lcd.begin(16, 2);  // Initialisieren des LCD mit 16 Zeichen und 2 Zeilen\n  lcd.setRGB(255, 0, 0);  // Hintergrundbeleuchtung auf Rot setzen\n\n  // Anzeigen einer Begr\u00fc\u00dfungsnachricht\n  lcd.print(\"Hallo,\");\n  lcd.setCursor(0, 1);\n  lcd.print(\"Arduino!\");\n}\n\nvoid loop() {\n  // Hier k\u00f6nnen Sie kontinuierlich aktualisierte Informationen auf dem Display anzeigen.\n}\n</code></pre>"},{"location":"EB2/Praktikum/1.%20Praktikum/Vorbereitung%20-%20Praktikum%201/","title":"Vorbereitung   Praktikum 1","text":"<ul> <li>Digitale Thermostatventilsteuerung</li> <li>2 Boards: <ul> <li>ATmega328P (auf Seeeduino V4-Board (rot))</li> <li>ARM Cortex M0 (auf einem Arduino Due (gr\u00fcn))</li> </ul> </li> <li>Erweitern mit Sensoren/Aktoren durch Grove-Starter Kit</li> </ul> <p>Note</p> <p>title: Eingangsspannung</p> <ul> <li>Rotes Board -&gt; 5V</li> <li>Gr\u00fcnes Board -&gt; 3,3V</li> </ul>"},{"location":"EB2/Praktikum/1.%20Praktikum/Vorbereitung%20-%20Praktikum%201/#durchfuhrung","title":"Durchf\u00fchrung","text":"<ol> <li>IDE laden, verschieben und Ausf\u00fchrungsberechtigungen verteilen <pre><code>cd ~/Downloads\nwget https://downloads.arduino.cc/arduino-ide/arduino-ide_2.0.0_Linux_64bit.zip\nunzip arduino-ide_2.0.0_Linux_64bit.zip\nmv arduino-ide_2.0.0_Linux_64bit ~/arduino-ide\nchmod +x ~/arduino-ide/arduino-ide\n</code></pre></li> <li>starten der IDE <pre><code>~/arduino-ide/arduino-ide\n</code></pre></li> </ol>"},{"location":"EB2/Praktikum/1.%20Praktikum/Vorbereitung%20-%20Praktikum%201/#konfiguration-der-ide","title":"Konfiguration der IDE","text":"<ol> <li>Sketchbook location <code>File-&gt;Preferences-&gt;Sketchbook location</code></li> <li>Arduino Due und Seeeduino \u00fcber Board Manager installieren<ol> <li>Rotes Board muss eingebunden werden:<ol> <li><code>https://raw.githubusercontent.com/Seeed-Studio/Seeed_Platform/master/package_legacy_seeeduino_boards_index.json</code></li> </ol> </li> </ol> </li> <li>Bibliotheken hinzuf\u00fcgen<ol> <li><code>Grove - LCD RGB Backlight</code> und <code>Servo by Michael Margolis, Arduino</code> </li> </ol> </li> </ol>"},{"location":"EB2/Praktikum/1.%20Praktikum/Vorbereitung%20-%20Praktikum%201/#programm","title":"Programm","text":"<p>Es soll ein Programm entworfen werden, welches folgende Komponenten ansteuern kann: - Eingebaute LED - serielle Schnittstelle \u00fcber USB zum PC - Taster - Potentiometer - Servo - Temperatursensor - LCDisplay</p>"}]}